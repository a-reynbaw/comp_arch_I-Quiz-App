[
  {
    "id": "8_2",
    "title": "E8.2 Προσομοίωση επεξεργαστή ενός κύκλου",
    "image": ["lab8_ex2"],
    "question": "Κατεβάστε το αρχείο `lab8.s` από το eClass του μαθήματος. Ακολουθήστε προσεκτικά τα παρακάτω βήματα.\n\n**αʹ.** Ανοίξτε τον προσομοιωτή QtRVsim.**βʹ.** Eπιλέξτε στο παράθυρο της Εικόνας 14 την επιλογή «No pipeline no cache». Πατήστε Start empty. **γʹ.** Φορτώστε τον κώδικα πατώντας το εικονίδιο με τον φάκελο. Έπειτα, μεταγλωττίστε τον πατώντας το εικονίδιο με το μπλε βέλος προς τα κάτω.\n\nΠραγματοποιήστε βηματική εκτέλεση μέχρι και την εντολή `lw x19, 0(x8)`. Συμπληρώστε την παρακάτω άσκηση βάσει της Εικόνας 16 και της περιγραφής που ακολουθεί.\n\n---\n\nαʹ. Το σήμα `rs1` έχει τιμή _____, ενώ το `rd` _____.\n\nβʹ. Οι δύο τιμές που βρίσκονται στην έξοδο του αρχείου καταχωρητών είναι ίσες με _____ και _____, οι οποίες οφείλονται στα περιεχόμενα των καταχωρητών _____  και _____.\n\nγʹ. Το σήμα ελέγχου `AuiPC` ισούται με _____ δίνοντας στην έξοδο του πρώτου (μετρώντας από πάνω προς τα κάτω) πολυπλέκτη στην είσοδο της ALU την τιμή _____ αντί της τιμής _____ που είναι η τιμή του _____.\n\nδʹ. Η πράξη που κάνει η ALU είναι _____. Για να δώσει 1 το σήμα `zero` στην έξοδο της ALU θα έπρεπε η δεύτερη (μετρώντας από πάνω προς τα κάτω) είσοδος της να είχε τιμή _____. Στην περίπτωση αυτή, το σήμα `BranchOutcome` θα είχε τιμή _____ αφού ________________________________________________________________________________.\n\nεʹ. Η τιμή που γράφεται στον καταχωρητή προορισμού _____ είναι _____ και προκύπτει από τη _____ . Αυτό ρυθμίζεται από το σήμα _____ που έχει τιμή _____. Στην περίπτωση που είχε αντίθετη τιμή, θα γραφόταν η τιμή ____.\n\n---\n\nΗ εκτέλεση μιας εντολής σε έναν επεξεργαστή ενός κύκλου μπορεί να χωριστεί σε 5 διακριτά μέρη όπως φαίνεται στην Εικόνα 16. Tο μέρος 1 περιλαμβάνει το διάβασμα του μετρητή προγράμματος (PC) που περιέχει τη διεύθυνση που χρησιμοποιείται για την πρόσβαση στη μνήμη εντολών του επεξεργαστή (Fetch). Στο επόμενο μέρος 2 (Decode), η εντολή αποκωδικοποιείται και διαβάζονται οι καταχωρητές προέλευσης. Η δεκαεξαδική της μορφή βρίσκεται στο σήμα Instruction, το οποίο οδηγείται στην *Μονάδα Ελέγχου (Control Unit)* και διαχωρίζεται στα σήματα ελέγχου μπροστά από το αρχείο καταχωρητών (Registers) και στην αποκωδικοποίηση του immediate πεδίου. Ανοίγοντας το παράθυρο Registers (Windows → Registers) βλέπετε τις τιμές των καταχωρητών. Σειρά έχει το μέρος 3 και η εκτέλεση της εντολής (Execute), στην οποία μετέχει η ALU. Στην είσοδο της λαμβάνει το περιεχόμενο του καταχωρητή rs1 και του immediate πεδίου για να υπολογίσει τη διεύθυνση, στην οποία γίνεται πρόσβαση για ανάγνωση δεδομένων στο επόμενο μέρος 4 (Mem). Τέλος, τα δεδομένα γράφονται στον καταχωρητή προορισμού rd στο τελευταίο μέρος 5 (WB).\n\nΕκτελέστε το υπόλοιπο πρόγραμμα και επαληθεύστε τα αποτελέσματα τόσο στους καταχωρητές όσο στη μνήμη (Windows → Memory και βάζετε τη διεύθυνση που υποδεικνύει η εντολή `.org` πριν το `.data`). Πόσες εντολές και πόσοι κύκλοι εκτελέστηκαν; Τι παρατηρείτε;",
    "solution": "αʹ. Το σήμα rs1 έχει τιμή **08**, ενώ το rd **19**.\n\nβʹ. Οι δύο τιμές που βρίσκονται στην έξοδο του αρχείου καταχωρητών είναι ίσες με **0x400** και **0x0**, οι οποίες οφείλονται στα περιεχόμενα των καταχωρητών **rs1** και **rd**.\n\nγʹ. Το σήμα ελέγχου AuiPC ισούται με **0** δίνοντας στην έξοδο του πρώτου (μετρώντας από πάνω προς τα κάτω) πολυπλέκτη στην είσοδο της ALU την τιμή **0x400** αντί της τιμής **0x0** που είναι η τιμή του **s0**.\n\nδʹ. Η πράξη που κάνει η ALU είναι **πρόσθεση**. Για να δώσει 1 το σήμα zero στην έξοδο της ALU θα έπρεπε η δεύτερη (μετρώντας από πάνω προς τα κάτω) είσοδος της να είχε τιμή **0xFC00 (που είναι το συμπλήρωμα του 16αδικού αριθμού 0χ400**. Στην περίπτωση αυτή, το σήμα BranchOutcome θα είχε τιμή **0** αφού **αυτό προκύπτει από τις πράξεις των λογικών πυλών ( ( ( 1 ^ 0 ) & 0 ) | 0 = 0)**.\n\nεʹ. Η τιμή που γράφεται στον καταχωρητή προορισμού **s3** είναι **1** και προκύπτει από τη **Data Memory**. Αυτό ρυθμίζεται από το σήμα **MemToReg** που έχει τιμή **1**. Στην περίπτωση που είχε αντίθετη τιμή, θα γραφόταν η τιμή **της AluOut = 0x400**."
  }
]
