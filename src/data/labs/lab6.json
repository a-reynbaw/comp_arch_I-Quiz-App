[
  {
    "id": "6_1",
    "title": "E6.1 Τελικό κρατούμενο",
    "image": ["lab6_ex1_1", "lab6_ex1_2"],
    "question": "Το ζητούμενο αυτής της άσκησης είναι ένας τρόπος παραγωγής κρατουμένου από τον αθροιστή 32 bit του RISC-V επειδή αυτό δεν προσφέρεται από τον συγκεκριμένο μικροεπεξεργαστή. Υποθέτουμε ότι ο αθροιστής της ALU του RISC-V αποτελείται από 32 πλήρεις αθροιστές (full adders) του ενός bit συνδεδεμένους μεταξύ τους με τα κρατούμενα εισόδου και εξόδου. Ο πίνακας αλήθειας ενός πλήρους αθροιστή για το bit i παρουσιάζεται στον Πίνακα 4. Θεωρείστε ότι τα \\(A_i\\) και \\(B_i\\) είναι τα δύο bit i-τάξης που πρόκειται να προστεθούν, \\(C_i\\) είναι το κρατούμενο που δίνει ο αθροιστής που προσθέτει τα \\(A_{i−1}\\) και \\(B_{i−1}\\), \\(S_i\\) είναι το άθροισμα ενώ \\(C_{i+1}\\) είναι το κρατούμενο που παράγει ο αθροιστής που προσθέτει τα \\(A_i\\) και \\(B_i\\).\n\nΓια να υπολογίσουμε το \\(C_{32}\\), χρειαζόμαστε τα \\(A_{31}\\), \\(B_{31}\\), \\(C_{31}\\). Τα \\(A_{31}\\), \\(B_{31}\\) μπορούμε να τα βρούμε πολύ εύκολα, κάτι που δεν ισχύει για το \\(C_{31}\\). Θέτοντας \\(i = 30\\), για να υπολογίσουμε το \\(C_{31}\\), χρειαζόμαστε τα \\(A_{30}\\), \\(B_{30}\\), \\(C_{30}\\). Αναδρομικά, φτάνουμε μέχρι και το bit 0 για το οποίο ισχύει \\(C_0 = 0\\).\n\nΥπάρχει τρόπος να εξαλείψουμε την αναδρομή απαιτώντας σαν είσοδο το άθροισμα \\(S_i\\) δεδομένου ότι για τον υπολογισμό του αθροίσματος λαμβάνονται υπόψιν και τα προηγούμενα κρατούμενα \\(C_0\\), \\(C_1\\), . . . , \\(C_i\\). Συμπληρώστε τον Πίνακα 5 που εκφράζει τον πίνακα αλήθειας του \\(C_{i+1}\\)_ όταν είναι γνωστά τα \\(A_i\\), \\(B_i\\) και \\(S_i\\) (αντί για το \\(C_i\\)).\n\nΚατόπιν, γράψτε ένα πρόγραμμα σε συμβολική γλώσσα RISC-V που να υπολογίζει το τελικό κρατούμενο μίας πρόσθεσης (\\(C_{32}\\)) μεταξύ δύο καταχωρητών και να το αποθηκεύει σε ένα bit κάποιου άλλου καταχωρητή. Οι αριθμοί που θα προστεθούν να εισάγονται στη μνήμη δεδομένων. Προκειμένου να διαπιστώσετε την ορθότητα του προγράμματός σας, προτείνεται να χρησιμοποιήσετε τα ζευγάρια αριθμών της Άσκησης E3.3.",
    "solution": "```\n# E6.1\n\n.text\n.globl __start\n\n__start:\n    li s0, -2147483647\n    li s1, -2\n\n    mv a0, s0\n    jal PrintInt\n    mv a0, s1\n    jal PrintInt\n\n    mv a0, s0\n    mv a1, s1\n    jal add\n\n    mv s0, a1\n    jal PrintInt\n\n    bnez s0, case_overflow\n    j Exit\n\n  case_overflow:\n    la a0, OVERFLOW_MSG\n    jal PrintString\n    j Exit\n\n#####################################\n\n# fn add(i32 a, i32 b) -> (i32, bool)\n#\n# Signed 32-bit addition with overflow detection.\n# Returns the sum `a + b` in `a0` and 1 in `a1` if\n# arithmetic overflow occurred.\n\nadd:\n    add t0, a0, a1\n\n    srli a0, a0, 31\n    srli a1, a1, 31\n    srli t1, t0, 31\n\n    # If both operands have different signs,\n    # there is no possibility of overflow.\n    bne a0, a1, .add_no_overflow\n\n  .add_possible_overflow:\n    # If the result has the same sign as\n    # the operands, then no overflow occurred.\n    beq a0, t1, .add_no_overflow\n\n  .add_overflow:\n    mv a0, t0\n    li a1, 1\n    j .add_done\n\n  .add_no_overflow:\n    mv a0, t0\n    xor a1, a1, a1\n\n  .add_done:\n    jr ra\n\n####################################\n\nPrintInt:\n    li a7, 1\n    ecall\n    la a0, NL\n    li a7, 4\n    ecall\n\nPrintString:\n    li a7, 4\n    ecall\n    jr ra\n\nExit:\n    li a7, 10\n    ecall\n\n.data\nNL: .asciz \"\\n\"\nOVERFLOW_MSG: .asciz \"overflow occurred!\\n\"\n```"
  },
  {
    "id": "6_2",
    "title": "E6.2 Πρόσθεση 64-bit αριθμών",
    "image": ["lab6_ex2_1", "lab6_ex2_2"],
    "question": "Στην άσκηση αυτή θα δημιουργήσετε ένα πρόγραμμα που θα μπορεί να κάνει πρόσθεση δύο προσημασμένων αριθμών A και B των 64 bit ο καθένας. Αρχικά οι αριθμοί θα βρίσκονται στη μνήμη δεδομένων και η διάταξή τους θα ακολουθεί το μοντέλο little-endian, δηλαδή η λέξη με τα λιγότερο σημαντικά bit θα βρίσκεται σε χαμηλότερη διεύθυνση όπως φαίνεται και στο σχήμα παρακάτω. Το αποτέλεσμα της άθροισης S θα αποθηκεύεται και αυτό στη μνήμη όπως δείχνει η Εικόνα 11. Εκμεταλλευτείτε την προηγούμενη άσκηση ώστε το πρόγραμμά σας να χρησιμοποιεί το κρατούμενο C32 στην πρόσθεση των bit στη θέση 32 (δηλαδή να «μεταφερθεί» το κρατούμενο από τη λέξη που αποθηκεύει τα 32 χαμηλότερα bit στη λέξη που αποθηκεύει τα 32 υψηλότερα bit).\n\nΠειραματιστείτε με τα ζευγάρια δυαδικών αριθμών της Εικόνας 12 και αφού συμπληρώσετε τα αθροίσματα συγκρίνετέ τα με τα αποτελέσματα που δίνει το πρόγραμμά σας.",
    "solution": "```\n# E6.2\n.text\n.globl __start\n\n__start:\n    la a0, A\n    la a1, B\n    la a2, C\n    jal add64\n    j Exit\n\n#####################################\n\n# fn add64(i64* a, i64* b, i64* result) -> bool\n#\n# Signed 64-bit addition with overflow detection.\n# Writes the sum `a + b` at `result` returns 1\n# in `a0` if arithmetic overflow occurred.\n\nadd64:\n  mv s0, a0\n  mv s1, a1n\n\n  # result[0:31] := a[0:31] + b[0:31]\n  lw a0, 0(s0)\n  lw a1, 0(s1)\n  add t0, a0, a1\n  sw t0, 0(a2)\n\n  # Detect overflow in the lower 32 bits. (t3)\n  srli a0, a0, 31\n  srli a1, a1, 31\n  srli t0, t0, 31\n  xor t1, a0, a1\n  not t1, t1\n  xor t2, a0, t0\n  and t3, t1, t2\n\n  # t0 := a[32:63] + b[32:63]\n  lw a0, 4(s0)\n  lw a1, 4(s1)\n  add t0, a0, a1\n\n  # Add the carry from the lower 32 bits.\n  add t0, t0, t3\n\n  # result[32:63] := t0\n  sw t0, 4(a2)\n\n  # Detect overflow in the 64-bit operation.\n  srli a0, a0, 31\n  srli a1, a1, 31\n  srli t0, t0, 31\n  xor t1, a0, a1\n  not t1, t1\n  xor t2, a0, t0\n  and a0, t1, t2\n\n  jr ra\n\n#####################################\n\nExit:\n    li a7, 10\n    ecall\n\n.data\nA: .word 14, 0\nB: .word 11, 0\nC: .word 0x00000000, 0x00000000\n```"
  },
  {
    "id": "6_3",
    "title": "E6.3 Πολλαπλασιασμός",
    "image": ["lab6_ex3"],
    "question": "Σε αυτή την άσκηση θα εξετάσουμε τη διαφοροποίηση των τεσσάρων πραγματικών εντολών πολλαπλασιασμού ακεραίων `mul` (multiply), `mulh` (multiply high), `mulhu` (multiply high unsigned) και `mulhsu` (multiply high signed/unsigned) που διαθέτει ο επεξεργαστής RISC-V. Η διαφορά τους βρίσκεται στο διαφορετικό τρόπο με τον οποίο μεταφράζουν τους τελεστέους της πράξης του πολλαπλασιασμού αλλά και η διαφορά στο αποτέλεσμα που δίνουν οι εντολές.\n\n**αʹ.** Να γράψετε ένα πρόγραμμα σε συμβολική γλώσσα RISC-V το οποίο αρχικά θα δεσμεύει στη μνήμη δεδομένων 2 δεκαεξαδικές τιμές μεγέθους λέξης 32 bit η καθεμία, χρησιμοποιώντας την οδηγία .word (έστω ότι τα ονόματα των δύο αυτών τιμών είναι x και y). Επίσης, θα δεσμεύει χώρο για τέσσερις ακόμα λέξεις.\n\n**Υπόδειξη:** Η δέσμευση του χώρου μπορεί να γίνει απλά, δεσμεύοντας τέσσερις λέξεις με την οδηγία .word και ως αρχική τιμή το 0.\n\n**βʹ.** Στη συνέχεια, φορτώστε τις δύο δεκαεξαδικές τιμές που ορίσατε σε δύο καταχωρητές. Έπειτα, χρησιμοποιήστε τις εντολές `mul`, `mulh`, `mulhu`, και `mulhsu` για να πολλαπλασιάσετε τους αριθμούς που φορτώσατε στους καταχωρητές και αποθηκεύστε τα αποτελέσματα στις τέσσερις διαδοχικές θέσεις μνήμης που δεσμεύσατε στο υποερώτημα **α’**.\n\n**γʹ.** Πειραματιστείτε με τα ζευγάρια αριθμών της Εικόνας 13. Φορτώστε και εκτελέστε το πρόγραμμά σας στον RARS και εκτελέστε το πρόγραμμα ξεχωριστά για κάθε ζευγάρι τιμών και συμπληρώστε τα αποτελέσματα της κάθε εντολής.\n\n**δʹ**. Εξηγείστε τη λειτουργία των εντολών `mulh`, `mulhu`, και `mulhsu` (στη γενική τους μορφή, ανεξάρτητα από τα αποτελέσματα που πήρατε).\n\n**εʹ**. Παρατηρείστε ότι στις περιπτώσεις των αριθμών **13βʹ** και **13γʹ** τα αποτελέματα των εντολών `mulh`, `mulhu`, και `mulhsu` δεν είναι πάντα ίδια. Για κάθε ένα από τα παραπάνω 3 ζευγάρια αριθμών, εξηγείστε πότε τα αποτελέσματα των εντολών `mulh`, `mulhu`, και `mulhsu` που πήρατε από την εκτέλεση του προγράμματος θα ήταν σωστά για κάθε μια από τις παρακάτω συνθήκες.\n\n- Τα ζευγάρια αριθμών που πολλαπλασιάζονται είναι πάντα προσημασμένοι αριθμοί\n\n- Τα ζευγάρια αριθμών που πολλαπλασιάζονται είναι πάντα μη προσημασμένοι αριθμοί\n\n- Στα ζευγάρια αριθμών που πολλαπλασιάζονται ο πολλαπλασιαστέος είναι προσημασμένος ενώ ο πολλαπλασιαστής είναι μη προσημασμένος\n\n**Υπόδειξη**: Θα διευκολύνετε τη σκέψη σας αν υπολογίσετε τα αποτελέσματα των αριθμών στο δεκαδικό σύστημα αρίθμησης και τα συγκρίνετε με τα αποτελέσματα του RARS επίσης στο δεκαδικό σύστημα αρίθμησης, για κάθε μια από τις τρεις παραπάνω συνθήκες. Θυμηθείτε ότι το αποτέλεσμα των εντολών `mulh`, `mulhu`, και `mulhsu` αφορά τα bit 32 έως 64 (δηλαδή, τα 32 πεισσότερο σημαντικά bit του αποτελέσματος).",
    "solution": "```\n# E6.3\n\n.text\n.globl __start\n\n__start:\n    la s0, results\n\n    la t0, x\n    la t1, y\n\n    lw t0, (t0)\n    lw t1, (t1)\n\n    mul a0, t0, t1\n    jal .write_result\n\n    mulh a0, t0, t1\n    jal .write_result\n\n    mulhsu a0, t0, t1\n    jal .write_result\n\n    mulhu a0, t0, t1\n    jal .write_result\n\n    j Exit\n\n  .write_result:\n    sw a0, (s0)\n    addi s0, s0, 4\n    jr ra\n\nExit:\n    li a7, 10\n    ecall\n\n.data\nx: .word 0x42010001\ny: .word 0x0002000f\n\nresults:\nmul:    .word 0\nmulh:   .word 0\nmulhu:  .word 0\nmulhsu: .word 0\n```"
  }
]
