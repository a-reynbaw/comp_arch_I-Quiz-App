[
  {
    "id": "4_1",
    "title": "E4.1 Ωφέλιμα bytes",
    "question": "Να γράψετε ένα πρόγραμμα σε συμβολική γλώσσα RISC-V το οποίο ο χρήστης θα πληκτρολογεί έναν προσημασμένο ακέραιο αριθμό και θα εμφανίζονται στην οθόνη τα παρακάτω μηνύματα, ανάλογα με τον αριθμό των bytes που απαιτούνται για την αναπαράσταση:\n\n- «The number fits in one byte»\n\n- «The number fits in two bytes»\n\n- «The number fits in four bytes»\n\nΘα υλοποιήσετε 2 παραλλαγές.\n\n**αʹ.** Θα εμφανίζονται μηνύματα για όσες περιπτώσεις ισχύουν. Για παράδειγμα, αν δόθηκε ο ακέραιος 127 θα εμφανιστούν και τα τρία μηνύματα. Εδώ ουσιαστικά πρόκειται για τη δομή `switch` της γλώσσας C χωρίς τη χρήση `break` ανάμεσα στους κλάδους.\n\n**βʹ.** Θα εμφανίζεται μήνυμα μόνο για μια περίπτωση. Για παράδειγμα, αν δόθηκε ο ακέραιος 128 θα εμφανιστεί μόνο το μήνυμα «The number fits in twobytes». Πρόκειται για τη δομή `switch` της γλώσσας C με χρήση `break` ανάμεσα στους κλάδους.",
    "solution": "```\n# Ε4.1\n\n#---------------------- text segment ---------------------#\n    .text\n    .globl ___start\n\n___start:  \n\n# read the number from input\n    li a7, 5\n    ecall\n\n# move the iputed int from a0 to another register\n    mv t0, a0\n\n### subexercise A ###\n# simulate a switch case with no break commands\n   la a0, ex_a_msg\n\n   li a7, 4\n   ecall\n\n# first check if the number fits in one byte\n    li t1, -128\n    blt t0, t1, check_two_bytes_a\n    li t1, 127\n    bgt t0, t1, check_two_bytes_a\n\n# print message\n    la a0, one_byte\n\n    li a7, 4\n    ecall\n\ncheck_two_bytes_a:\n    li t1, -32768\n    blt t0, t1, check_four_bytes_a\n    li t1, 32767\n    bgt t0, t1, check_four_bytes_a\n\n# print message\n    la a0, two_bytes\n    li a7, 4\n    ecall\n\ncheck_four_bytes_a:\n   li t1, -2147483648\n    blt t0, t1, ex_b  # in fact, there is no reason to perform the same check\n                      # if it doesn't fit in four bytes, but branch there for\n                      # consistency\n    li t1, 2147483647\n    bgt t0, t1, ex_b\n\n# print message\n   la a0, four_bytes\n\n    li a7, 4\n    ecall\n\n### subexercise B ###\n# simulate a switch case with break commands\n\nex_b:\n   la a0, ex_b_msg\n\n   li a7, 4\n   ecall\n\n# first check if the number fits in one byte\n    li t1, -128\n    blt t0, t1, check_two_bytes_b\n    li t1, 127\n    bgt t0, t1, check_two_bytes_b\n\n# print message\n    la a0, one_byte\n\n    li a7, 4\n    ecall\n\n# no need to check any further\n    j exit\n\ncheck_two_bytes_b:\n    li t1, -32768\n    blt t0, t1, check_four_bytes_b\n    li t1, 32767\n    bgt t0, t1, check_four_bytes_b\n\n# print message\n    la a0, two_bytes\n\n    li a7, 4\n    ecall\n\n    j exit\n\ncheck_four_bytes_b:\n    li t1, -2147483648\n    blt t0, t1, ex_b  # in fact, there is no reason to perform the same check\n                      # if it doesn't fit in four bytes, but branch there for\n                      # consistency\n    li t1, 2147483647\n    bgt t0, t1, ex_b\n\n# print message\n    la a0, four_bytes\n\n    li a7, 4\n    ecall\n\nexit:\n    li a7, 10\n    ecall\n\n\n#---------------------- data segment ---------------------#\n\n    .data\nex_a_msg:     .asciz \"Exercise A\\n\"\nex_b_msg:     .asciz \"Exercise B\\n\"\none_byte:     .asciz \"This number fits in one byte.\\n\"\ntwo_bytes:    .asciz \"This number fits in two bytes.\\n\"\nfour_bytes:   .asciz \"This number fits in four bytes.\\n\"\n```"
  },
  {
    "id": "4_2",
    "title": "E4.2 Απόσταση Hamming",
    "question": "Η απόσταση Hamming (Hamming Distance) είναι ένα μέτρο που χρησιμοποιείται για τη σύγκριση δύο δυαδικών ακολουθιών ίδιου μήκους, υπολογίζοντας τον αριθμό των θέσεων στις οποίες τα αντίστοιχα bit τους διαφέρουν. Για παράδειγμα η απόσταση Hamming των ακολουθιών 110**01**010 και 110**10**010 είναι 2. Να γράψετε ένα πρόγραμμα σε συμβολική γλώσσα RISC-V το οποίο θα υπολογίζει την απόσταση Hamming δύο λέξεων των 32 bit που είναι αποθηκευμένες στη μνήμη.",
    "solution": "```\n# E4.2\n#---------------------- text segment ---------------------#\n    .text\n    .globl ___start\n\n___start:\n\n# load the numbers from memory to registers s0 and s1\n    la t0, num1\n    lw s0, 0(t0)\n\n    lw s1, 4(t0)  # using offset 4 on the address of num1 is the\n                  # same as loading the address of num2 and\n                  # using offset 0\n\n# XOR the two numbers to find the bits the differ\n    xor t0, s0, s1 #xor-ed value\n\n# initialize a counter, a target and a sum for the loop\n    li t1, 0   #counter\n    li t2, 32  #target\n\n    li s0, 0   #sum\n\nloop:\n    beq t1, t2, exit   # if the counter has reached 32, break from the loop\n\n    #create a bit mask to get the lsb\n    li t3, 1\n\n    and t3, t3, t0\n\n    # update the sum\n    add s0, s0, t3\n\n    # shift the xor-ed value to the right by 1\n    srli t0, t0, 1\n\n    # increase the counter\n    addi t1, t1, 1\n\n    j loop\nexit:\n# print the Hamming distance\n    la a0, msg\n    li a7, 4\n    ecall\n\n    mv a0, s0\n    li a7, 1\n    ecall\n\n    li a7, 10\n    ecall\n\n#---------------------- data segment ---------------------#\n    .data\nnum1:    .word 0\nnum2:    .word -1\nmsg:     .asciz \"The Hamming distance is: \"\n```"
  },
  {
    "id": "4_3",
    "title": "E4.3 Μετατροπή πεζών γραμμάτων σε κεφαλαία",
    "question": "Γράψτε ένα πρόγραμμα που θα δέχεται σαν είσοδο από το χρήστη μία ακολουθία χαρακτήρων και θα τυπώνει στην έξοδο την ίδια ακολουθία με κεφαλαία γράμματα (όπου υπάρχουν χαρακτήρες '`a`'-'`z`' θα αντικαθίστανται με τους '`A`'-'`Z`').",
    "solution": "```\n# E4.3\n\n#---------------------- text segment ---------------------#\n    .text\n    .globl ___start\n\n___start:\n\n# read a string from the input\n    li a7, 8\n    la a0, inword     # load inword address\n    li a1, 100        # max characters to read\n    ecall\n\n    la a1, inword     # Load inword address\n\n# loop through the string until the null byte is encountered\nloop:\n    # load a byte (character)\n    lb t0, 0(a1)\n\n    # if the byte is the null byte, go to printing\n    beqz t0, print\n\n    # check if the letter is already uppercase (less that a)\n    # or not a letter (greater than z)\n    li t1, 'a'\n    li t2, 'z'\n\n    blt t0, t1, next\n    bgt t0, t2, next\n\n    # make the letter uppercase\n    addi t0, t0, -32\n\n    # store the changed byte\n    sb t0, 0(a1)\n\nnext:\n    # move forward by a byte\n    addi a1, a1, 1\n\n    # repeat the process\n    j loop\n\n\nprint:\n\n    # add the null byte at the end\n    sb zero, 0(a1)\n\n    # move at the start of the string by loading the initial address\n    la a0, inword\n\n    # and print the word with the uppercase letters\n    li a7, 4\n    ecall\n\n    li a7, 10          \n    ecall\n\n#---------------------- data segment ---------------------#\n    .data\ninword:   .asciz\n```"
  }
]
