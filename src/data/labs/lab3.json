[
  {
    "id": "3_1",
    "title": "E3.1 Ο κώδικας Gray",
    "image": ["lab3_ex1"],
    "question": "Να γράψετε ένα πρόγραμμα με όνομα lab3_ex1.s σε συμβολική γλώσσα RISC-V που να μετατρέπει έναν δυαδικό αριθμό των 32-bit στον αντίστοιχό του σε κωδικοποίηση Gray. Ο αλγόριθμος μετατροπής ενός δυαδικού αριθμού με n bits σε αναπαράσταση κώδικα Gray δίνεται από την Εξίσωση 1. \\[ g_i= \\begin{cases}b_i, & i=n-1\\\\ b_{i+1} \\oplus b_i, & i=0,1,\\ldots,n-2\\end{cases} \\]\n\n **Υπόδειξη:** Ο αριθμός θα εισάγεται απευθείας σε ένα καταχωρητή. Αυτό γίνεται με διπλό κλικ στο περιεχόμενο του επιθυμητού καταχωρητή στο υπο-παράθυρο των καταχωρητών του RARS. Βεβαιωθείτε ότι τα περιεχόμενα των καταχωρητών εμφανίζονται σε δεκαεξαδική μορφή ώστε να είναι εύκολη η μετατροπή τους σε δυαδικό σύστημα (από το μενού Settings πρέπει να είναι ενεργοποιημένη η επιλογή Values displayed in hexadecimal).\nΠειραματιστείτε με μικρούς αριθμούς και συμβουλευτείτε τον παραπάνω πίνακα αντιστοίχισης για τον κώδικα Gray των 4 bit για να επιβεβαιώσετε το αποτέλεσμα, παρατηρώντας τον Gray κωδικοποιημένο αριθμό που θα βρίσκεται σε έναν καταχωρητή της επιλογής σας.",
    "solution": "```\n# E3.1\n\n#---------------------- text segment ---------------------#\n\n    .text              # Program code goes in this section\n    .globl __start\n\n__start:               # Execution starts here\n\n\n\n    # Your program code goes here...\n    # shift the value in a0 to the right by 1 and save it to t0\n    srli t0, a0, 1\n    # xor the values of t0 and a0 and save them to a1\n    xor a1, a0, t0\n\n\n    li  a7, 10         # Done, terminate program\n    ecall              # au revoir...\n\n\n\n#---------------------- data segment ---------------------#\n\n    .data   # Data declarations go in this section.\n\n\n\n#----------------------- End of File ---------------------#\n```"
  },
  {
    "id": "3_2",
    "title": "E3.2 Μετατροπή από big-endian σε little-endian",
    "image": ["lab3_ex2"],
    "question": "Όπως έχουμε μάθει, κατά κανόνα οι επεξεργαστές της αρχιτεκτονικής RISC-V λειτουργούν χρησιμοποιώντας το μοντέλο μνήμης little-endian (μικρού άκρου) για την οργάνωση των byte. Υποθέστε ότι ένας τέτοιος RISC-V επεξεργαστής επικοινωνεί με διάφορες άλλες μηχανές, κάποιες από τις οποίες χρησιμοποιούν το μοντέλο μνήμης big-endian (μεγάλου άκρου) για την οργάνωση των byte. Τα δεδομένα που προέρχονται από τις άλλες μηχανές είναι λέξεις των 32 bit και εισάγονται σε έναν καταχωρητή, όχι όμως με τη μορφή που τα χρειάζεται ο RISC-V. Σε αυτή την άσκηση θέλουμε με προγραμματιστικό τρόπο σε συμβολική γλώσσα RISC-V να μετατρέψουμε τα δεδομένα που λαμβάνονται από τη «λανθασμένη» μορφή big-endian στη μορφή little-endian σε έναν άλλο καταχωρητή, όπως φαίνεται στην Εικόνα 9.\n**ΣΗΜΑΝΤΙΚΟ**. Να σημειωθεί ότι μέσα σε κάθε byte η σειρά των bit είναι η σωστή (δηλαδή το byte 0 αποθηκεύει τα bit 7-0, το byte 1 αποθηκεύει τα bit 15-8, κ.λπ.) Να γράψετε το σχετικό πρόγραμμα μετατροπής σε συμβολική γλώσσα RISC-V, χωρίς να χρησιμοποιήσετε καθόλου προσπέλαση στη μνήμη, παρά μόνο με λογικές πράξεις μεταξύ καταχωρητών και αυτό για λόγους ταχύτητας επεξεργασίας.",
    "solution": "```\n# E3.2\n\n#---------------------- text segment ---------------------#\n\n    .text              # Program code goes in this section\n    .globl __start\n\n__start:               # Execution starts here\n\n# suppose that value to be processed is already in register s0\n\n# make a mask for the first byte\n    li t0, 0xff000000\n\n# save the first byte to t1\n    and t1, s0, t0\n\n# add t1 to a new register, shifted by 12 to the left\n    srli t1, t1, 24\n\n    mv t2, t1\n\n# repeat this process tree more times\n    li t0, 0x00ff0000\n    and t1, s0, t0\n    srli t1, t1, 8\n    or t2, t2, t1\n    li t0, 0x0000ff00\n    and t1, s0, t0\n    slli t1, t1, 8\n    or t2, t2, t1\n    li t0, 0x000000ff\n    and t1, s0, t0\n    slli t1, t1, 24\n    or t2, t2, t1\n\n    li  a7, 10         # Done, terminate program\n    ecall              # au revoir...\n\n\n#---------------------- data segment ---------------------#\n\n    .data   # Data declarations go in this section.\n\n\n\n#----------------------- End of File ---------------------#\n```"
  },
  {
    "id": "3_3",
    "title": "E3.3 Πρόσθεση και Υπερχείλιση",
    "image": ["lab3_ex3"],
    "question": "**αʹ.** Θεωρήστε τα ζευγάρια προσημασμένων δυαδικών αριθμών των 32-bit σε αναπαράσταση συμπληρώματος ως προς 2 της Εικόνας 10. Κάντε τις προσθέσεις που φαίνονται σε δυαδικό και στο δεκαδικό σύστημα και συμπληρώστε το αποτέλεσμα στα αντίστοιχα κουτάκια παρακάτω. Επίσης συμπληρώστε το σχετικό bit V της υπερχείλισης (1 αν έχει συμβεί υπερχείλιση και 0 αν δεν έχει συμβεί). Επιπλέον συμπληρώστε τα κρατούμενα που δίνει η πρόσθεση στα bit τελευταίας και προτελευταίας τάξης, δηλαδή τα C32 και C31, αντίστοιχα. ΠΡΟΣΟΧΗ. Τα bit C32, C31 και V δεν υπάρχουν στον RISC-V αλλά τα χρησιμοποιούμε εδώ απλά ως συμβολισμό της άσκησης.\n\n**βʹ.** Ελέγξτε κατά πόσον το αποτέλεσμα στο δεκαδικό σύστημα είναι ίδιο με αυτό της δυαδικής αναπαράστασης.\n\n**γʹ.** Αρχικά, εισάγετε τα παραπάνω ζευγάρια αριθμών στο τμήμα δεδομένων. Προτείνεται να εισάγετε τα δεδομένα ως λέξεις και να χρησιμοποιήσετε μια ετικέτα (`label`) για κάθε έναν αριθμό που θα δηλώσετε, ώστε να είναι ευκολότερη η χρήση των αριθμών μετέπειτα από το πρόγραμμά σας.\n\n**δʹ.** Να γράψτε ένα πρόγραμμα σε συμβολική γλώσσα RISC-V το οποίο θα φορτώνει από τη μνήμη ένα-ένα το κάθε ζευγάρι αριθμών σε δύο καταχωρητές, θα τους προσθέτει με την εντολή add και θα αποθηκεύει το αποτέλεσμα σε έναν τρίτο καταχωρητή. Αυτό θα το κάνετε και για τα τέσσερα ζευγάρια αριθμών αλλά χρησιμοποιώντας διαφορετικούς καταχωρητές για κάθε αποτέλεσμα. Ουσιαστικά, το πρόγραμμα που θα γράψετε θα εκτελεί τις ίδιες πράξεις που κάνατε στα προηγούμενα υπο-ερωτήματα «με το χέρι». **Υπόδειξη:** Βεβαιωθείτε ότι τα περιεχόμενα των καταχωρητών εμφανίζονται σε δεκαεξαδική μορφή ώστε να είναι εύκολη η μετατροπή τους σε δυαδικό σύστημα (από το μενού Settings πρέπει να είναι ενεργοποιημένη η επιλογή Values displayed in hexadecimal).\n\n**εʹ.** Επεκτείνετε τη λειτουργία του προγράμματος που γράψατε στο προηγούμενο υποερώτημα έτσι ώστε να εκτυπώνει τα τέσσερα αποτελέσματα των προσθέσεων στην οθόνη (στην καρτέλα Run I/O του RARS).\n\n**στʹ.** Πού φαίνεται αν έχει συμβεί υπερχείλιση;\n\n**ζʹ.** Ποια λογική συνάρτηση μεταξύ των C31 και C32 δίνει την υπερχείλιση; Γιατί να επιλεγεί να υλοποιηθεί ένας τέτοιος μηχανισμός ανίχνευσης παρά ένας συγκριτής των εισόδων με το άθροισμα;",
    "solution": "```\n# E3.3\n\n#---------------------- text segment ---------------------#\n\n    .text              # Program code goes in this section\n    .globl __start\n\n__start:               # Execution starts here\n\n    #      Binary Representation                  Decimal\n    #    00111111 11111111 11111111 11111111   |   +1, 073, 741, 823\n    # +  00111111 11111111 11111111 11111111   | + +1, 073, 741, 823\n    # ---------------------------------------- | --------------------\n    # =  01111111 11111111 11111111 11111110   | = +2  147  483  646\n\n    #  V: 0,  C32: 0, C31: 0\n\n\n    #      Binary Representation                  Decimal\n    #    01111111 11111111 11111111 11111111   |   +2, 147, 483, 647\n    # +  00000000 00000000 00000000 00000001   | +                +1\n    # ---------------------------------------- | --------------------\n    # =  10000000 00000000 00000000 00000000   | = +2  147  483  648\n\n    #  V: 0,  C32: 0, C31: 1\n\n\n    #      Binary Representation                  Decimal\n    #    10000000 00000000 00000000 00000000   |   -2, 147, 483, 647\n    # +  11111111 11111111 11111111 11111111   | +                -1\n    # ---------------------------------------- | --------------------\n    # =  01111111 11111111 11111111 11111111   | = +2  147  483  646\n\n    #  V: 1,  C32: 1, C31: 0\n\n\n    #      Binary Representation                  Decimal\n    #    11111111 11111111 11111111 11111111   |                  -1\n    # +  11111111 11111111 11111111 11111111   | +                -1\n    # ---------------------------------------- | --------------------\n    # =  11111111 11111111 11111111 11111110   | =                -2\n\n    #  V: 1,  C32: 1, C31: 1\n    # all binary sums match to their decimal ones, exept for the third one,\n    # instead of getting a smaller, negative, number, the output was a positive\n    # one.\n\n    # question 4\n    la t0, nums\n\n    lw a0, 0(t0)\n    lw a1, 4(t0)\n    add a2, a0, a1\n\n    lw a3, 8(t0)\n    lw a4, 12(t0)\n    add a5, a3, a4\n\n    lw a6, 16(t0)\n    lw a7, 20(t0)\n    add t1, a6, a7\n\n    lw t2, 24(t0)\n    lw t3, 28(t0)\n    add t4, t2, t3\n\n    # question 5\n    mv a0, a2\n    li a7, 34\n    ecall\n\n    mv a0, a5\n    li a7, 34\n    ecall\n\n    mv a0, t1\n    li a7, 34\n    ecall\n\n    mv a0, t4\n    li a7, 34\n    ecall\n\n    li  a7, 10         # Done, terminate program\n    ecall              # au revoir...\n\n    # question 6\n    # when printing the message 0x7ffffffe0x7fffffff0x000000000xfffffffe:\n    # for each of the numbers that are printed in hex representation, the\n    # previous calculations are verified\n\n    # question 7\n    # The overflow (V) is determined by the XOR operation of the two carry bits,\n    # C32 and C31.This mechanism is preferred due to its speed and simplicity,\n    # as well as its ability to eliminate unnecessary operations.\n\n\n#---------------------- data segment ---------------------#\n\n    .data   # Data declarations go in this section.\n   # question 3\nnums:       .word 0x3FFFFFFF\n            .word 0x00000000\n            .word 0x80000000\n     .word 0xFFFFFFFF\n\n\n\n#----------------------- End of File ---------------------#\n```"
  }
]
