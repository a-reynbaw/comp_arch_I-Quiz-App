[
  {
    "id": "5_1",
    "title": "E5.1 Πράξεις με συμβολοσειρές",
    "question": "Αρκετές γλώσσες προγραμματισμού, όπως η Java και η Python, παρέχουν τη συνάρτηση `split()` η οποία διαχωρίζει μια συμβολοσειρά βάσει ενός διαχωριστή (`delimiter`). Το πρόγραμμα lab5_ex1.s που υπάρχει στο eClass του μαθήματος υλοποιεί μια περίπτωση της `split()`. Συγκεκριμένα, διαβάζει μια συμβολοσειρά από το χρήστη και καλεί τη διαδικασία find που είναι υπεύθυνη για την εύρεση ενός χαρακτήρα μέσα σε μια συμβολοσειρά. Έπειτα, αντικαθιστά τα κοινά σημεία με τον χαρακτήρα NULL και εκτυπώνει το κάθε μέρος χωριστά.\n\nΚαλείστε να υλοποιήσετε τη διαδικασία find, η οποία θα δέχεται τρία ορίσματα: τη διεύθυνση μιας συμβολοσειράς `str1`, έναν χαρακτήρα `ch` και τη διεύθυνση ενός πίνακα A. Η διαδικασία θα εντοπίζει τις θέσεις στις οποίες εμφανίζεται ο χαρακτήρας `ch` μέσα στην `str1` και θα αποθηκεύει στον πίνακα A τους δείκτες των εμφανίσεων (ξεκινώντας από το 0) χρησιμοποιώντας αποκλειστικά αποθηκευμένους (s) καταχωρητές για ενδιάμεσες πράξεις. Επίσης, θα αποθηκεύει στον καταχωρητή a1 την τιμή 0 αν δεν εντόπισε καμία θέση.\n\nΤρέξτε το πρόγραμμα με βηματικό τρόπο για να παρακολουθείτε τη στοίβα να «μεγαλώνει» και να «μικραίνει», δηλαδή να προστίθενται σε αυτή και να αφαιρούνται από αυτή στοιχεία. Παρακολουθήστε τα περιεχόμενα του καταχωρητή δείκτη στοίβας `sp`.",
    "solution": "```\n# Ε5.1\n\n    .text\n    .globl __start\n__start:\n    la a0, input_str\n    li a1, 21               # maximum input length + 1\n    jal read_str\n    li a1, ' '              # delimiter\n    la a2, A\n    li s0, 0\n    li s1, 20               # maximum input length\n    mv s2, a0\n    li s3, -1               # the smaller index - 1\n    jal find\n    jal print_endl\n    beqz a1, split_end      # just print the string if no delimiter found\n\nsplit:\n    bgt s0, s1, split_end   # characters count\n    lw s4, 0(a2)\n    blt s4, s3, split_end   # end loop if current index is smaller than the last one\n    mv s3, s4               # store the last index\n    add s5, s4, s2          # string address + index\n    sb zero, 0(s5)\n    jal print_str           # a0 contains the address of a portion of a string\n    jal print_endl\n    addi a0, s5, 1          # (string address + index) + 1\n    addi a2, a2, 4\n    addi s0, s0, 1\n    j split\n\nsplit_end:\n    jal print_str\n    jal print_endl\n    j exit\n\nfind:\n# a0 contains the address of the string\n# a1 contains the delimiter\n# a2 contains the array\n\n# we first need to store the contains of the registers\n# that will be used localy, since we are restricted\n# to use only s-register, which are \"stored registers\"\n\n# first make room on the stack by reducing the value of\n# sp (stack pointer)\n    addi sp, sp, -28\n    sw s0, 0(sp)\n    sw s1, 4(sp)\n    sw s2, 8(sp)\n    sw s3, 12(sp)\n    sw s4, 16(sp)\n    sw ra, 20(sp) # store the return address on the stack as well\n\n    mv s3, a2   # s3 = base address of array A\n    li s2, 0    # s2 = offset/index\n    mv s1, a0   # s1 = pointer to input string\n    mv s4, a1   # s0 = delimiter character\n\n    li a1, 0    # flag if at least one character\n                # equal to the delimeter is found\n                # (default = 0)\n\nloop:\n\n    lb s0, 0(s1)       # load byte/character from the string\n    beqz s0, finish    # if null terminator, end\n    bne s4, s0, next   # if not equal to delimiter, continue loop\n\n    sw s2, 0(s3)       # store the index to A\n    addi s3, s3, 4     # move pointer in A (word == 4 bytes)\n    li a1, 1           # set flag to 1 to mark that at least\n                       # one character has matched\n\nnext:\n    addi s1, s1, 1     # move to the next character\n    addi s2, s2, 1     # increase the offset\n\n    j loop\n\nfinish:\n# Restore registers from stack and stack pointer before returning\n    lw s0, 0(sp)\n    lw s1, 4(sp)\n    lw s2, 8(sp)\n    lw s3, 12(sp)\n    lw s4, 16(sp)\n    lw ra, 20(sp)\n    addi sp, sp, 28\n    jr ra\n\nread_str:\n    li a7, 8\n    ecall\n    jr ra\n\n\nprint_str:\n    li a7, 4\n    ecall\n    jr ra\n\nprint_endl:\n    addi sp, sp, -8\n    sw a0, 4(sp)\n    sw ra, 0(sp)\n\n    la a0, endl\n    jal print_str\n\n    lw ra, 0(sp)\n    lw a0, 4(sp)\n    addi sp, sp, 8\n   jr ra\n\nexit:\n    li a7, 10\n    ecall\n\n\n    .data\ninput_str:      .space 21\nA:              .word  0, 0, 0, 0, 0\n                .word  0, 0, 0, 0, 0\n                .word  0, 0, 0, 0, 0\n                .word  0, 0, 0, 0, 0\n                .word  0, 0, 0, 0, 0\nendl:           .asciz \"\\n\"\n```"
  },
  {
    "id": "5_2",
    "title": "E5.2 Ακολουθία Fibonacci",
    "image": ["lab5_ex2"],
    "question": "Είναι γνωστό ότι πολλοί μαθηματικοί ορισμοί βασίστηκαν σε στοιχεία της φύσης. Η ακολουθία Fibonacci, για παράδειγμα, βασίστηκε στον αριθμό από ζεύγη κουνελιών που θα παραχθούν από ένα αρχικό ζεύγος μέσα σε \\(n\\) μήνες. Επιπλέον, παρατηρείται σε σπειροειδή σχέδια διαφόρων φυτών, όπως ανανάδες, κουκουνάρια, κ.α.\n\nΗ μαθηματική σχέση που εκφράζει την ακολουθία Fibonacci περιγράφεται στην Εξίσωση 2.\n\n \\[ f(n) = \\begin{cases}n, & n \\in \\{0, 1\\}\\\\ f(n - 1) + f(n - 2), & n \\gt 1 \\end{cases}\\]\n\nΠαρατηρήστε ότι ο ορισμός γίνεται αναδρομικά: Ο \\(n\\)-οστός όρος υπολογίζεται ως το άθροισμα των δύο προηγούμενων όρων της ακολουθίας.\n\nαʹ. Κατεβάστε το πρόγραμμα lab5_ex2_fib_rec.s που θα βρείτε στο eClass του μαθήματος. Περιλαμβάνει την κύρια μέθοδο, η οποία καλεί τη διαδικασία fib_rec και αποθηκεύει τους πρώτους 40 όρους της ακολουθίας Fibonacci στη μνήμη. Καλείστε να γράψετε τη διαδικασία fib_rec η οποία υπολογίζει το \\(n\\)-οστο όρο της ακολουθίας Fibonacci χρησιμοποιώντας την Εξίσωση 2.\n\nΓια να ελέγξετε την ορθότητα του προγράμματος σας, αλλάξτε την κύρια διαδικασία ώστε να υπολογίζει μόνο τους 5 πρώτους όρους της ακολουθίας. Πιθανόν να χρειαστεί και βηματική εκτέλεση του κώδικα σας ώστε να ανακαλύψετε λογικά σφάλματα.\n\nΑφού πειστείτε ότι το πρόγραμμα σας δουλεύει για τους 5 πρώτους όρους της ακολουθίας, επαναφέρετε την κύρια μέθοδο στην αρχική της κατάσταση, και δοκιμάστε να τρέξετε το πρόγραμμα σας για 40 όρους. Τι παρατηρείτε; Μπορείτε να το εξηγήσετε;\n\nβʹ. Στη συνέχεια, κατεβάστε το πρόγραμμα lab5_ex2_fib_memo.s.\nΣε αυτό το ερώτημα καλείστε να γράψετε μια πιο αποδοτική έκδοση έναντι της απλής αναδρομικής του προηγούμενο ερωτήματος χρησιμοποιώντας την τεχνική του memoization («απομνημόνευση»).\n\nΤο memoization δουλεύει ως εξής: Οι τιμές της ακολουθίας που ήδη υπολογίστηκαν αποθηκεύονται στην μνήμη, ώστε να αποφεύγεται ο επανυπολογισμός τους σε περίπτωση που χρειαστεί να χρησιμοποιηθούν ξανά.\n\nΠαρατηρήστε ότι η κύρια μέθοδος αποθηκεύει στην μνήμη τους δύο πρώτους όρους της ακολουθίας και στη συνέχεια καλεί τη μέθοδο fib_memo για να υπολογίσει τους όρους 2 έως και 40.\n\nΣυμπληρώσετε τη μέθοδο fib_memo με τέτοιο τρόπο ώστε οι τιμές της ακολουθίας που ήδη υπάρχουν στον πίνακα να επιστρέφονται αμέσως, χωρίς περαιτέρω αναδρομικές κλήσεις.\n\nγʹ. Συμπληρώστε τον Πίνακα 3, καταγράφοντας πόσες εντολές εκτελούνται για να υπολογιστούν οι πρώτοι 5, 10 και 20 όροι της ακολουθίας με κάθε μία από τις δύο μεθόδους που υλοποιήσατε στα προηγούμενα ερωτήματα. Για να βλέπετε το πλήθος των εντολών που εκτελέστηκαν μπορείτε να ανοίξετε το παράθυρο με τα στατιστικά των εντολών πατώντας Tools→Instruction Statistics, και να επιλέξετε Connect to Program πριν εκτελέσετε τον κώδικα σας. Για να επαναφέρετε τα στατιστικά σε μηδενικά χρησιμοποιήστε το Reset.",
    "solution": "**fibonacci rec:**\n\n```\n# E5.2 rec\n    .text\n    .globl __start\n__start:\n    li s0, 20                   # number of terms to compute\n    li s1, 0                    # index of current term\n    la s2, fib_results\nmain_loop:\n    mv a0, s1                   # compute fib(s1)\n    jal fib_rec\n    sw a1, 0(s2)                # store result in fib_results[s1]\n    addi s2, s2, 4              # increment pointer to next result\n    addi s1, s1, 1              # increment index\n    bne s0, s1, main_loop       # loop until all terms are computed\n\nexit:\n    li a7, 10\n    ecall\n\n################################################################################\n\n# int fib_rec(int n)\nfib_rec:\n    beqz a0, fib_rec_case_0\n    li t0, 1\n    beq a0, t0, fib_rec_case_1\n\n    # The RISC-V manual says that we should try arranging code\n    # such that the most common path is not reached via branching.\n    # Some implementations might yield better performance this way.\n  fib_rec_case_recursive:\n    addi sp, sp, -12\n    sw ra, 8(sp) # return address\n    sw a0, 4(sp) # n\n    #      0(sp) # fib(n-1) + fib(n-2) sum\n\n    # Compute fib(n-1)\n    addi a0, a0, -1\n    jal fib_rec\n    sw a1, 0(sp)\n\n    # Compute fib(n-2)\n    lw a0, 4(sp)\n    addi a0, a0, -2\n    jal fib_rec\n\n    # Compute fib(n-1) + fib(n-2)\n    lw a0, 0(sp)\n    add a1, a0, a1\n\n    lw ra, 8(sp)\n    addi sp, sp, 12\n    jr ra\n\n  fib_rec_case_0:\n    xor a1, a1, a1\n    jr ra\n\n  fib_rec_case_1:\n    li a1, 1\n    jr ra\n\n################################################################################\n\n    .data\nfib_results:   .space 160   # space for first 40 terms of fib sequence\n```\n\n---\n\n**fibonacci memo:**\n\n```\n# E5.2 memo\n    .text\n    .globl __start\n__start:\n    li s0, 40                       # number of terms to compute\n    li s1, 2                        # index of current term\n    li s2, 1                        # const value 1\n    la s3, fib_results\n    sw zero, 0(s3)                  # store fib(0) in fib_results[0]\n    sw s2, 4(s3)                    # store fib(1) in fib_results[1]\nmain_loop:\n    mv a0, s1                       # compute fib(s1)\n    jal fib_memo\n    addi s1, s1, 1                  # increment index\n    bne s0, s1, main_loop           # loop until all terms are computed\n\nexit:\n    li a7, 10\n    ecall\n\n################################################################################\n\n# int fib_memo(int n)\nfib_memo:\n    # Have we memoized the value for this `n` yet?\n    lw t0, _fib_memo_internal_index\n    la t1, _fib_memo_internal_storage\n\n    blt a0, t0, fib_memo_memoized\n    beq a0, t0, fib_memo_can_compute\n\n  fib_memo_not_memoized:\n    addi sp, sp, -12\n    sw ra, 8(sp) # return address\n    sw a0, 4(sp) # n\n    #      0(sp) # fib(n-1)\n\n    # Compute fib(n-1)\n    addi a0, a0, -1\n    jal fib_memo\n    sw a0, 0(sp)\n\n    # Compute fib(n-2)\n    lw a0, 4(sp)\n    addi a0, a0, -2\n    jal fib_memo\n\n    # Compute fib(n-1) + fib(n-2)\n    lw t3, 0(sp)\n    add t3, t3, a0\n\n    # Memoize the result.\n    lw t0, _fib_memo_internal_index\n    la t1, _fib_memo_internal_storage\n\n    # Write value to storage.\n    li t5, 4\n    mul t5, t5, t0\n    add t5, t5, t1\n    sw t3, (t5)\n\n    # Increment index.\n    addi t0, t0, 1\n    la t1, _fib_memo_internal_index\n    sw t0, (t1)\n\n    mv a0, t3\n    jr ra\n  fib_memo_memoized:\n    # Load value from storage.\n    li t5, 4\n    mul t5, t5, a0\n    add t5, t5, t1\n    lw a0, (t5)\n    jr ra\n\n  fib_memo_can_compute:\n    # Compute from memoized values.\n    li t5, 4\n    mul t5, t5, t0\n    add t5, t5, t1\n\n    # Load memoized values for `n-1` and `n-2`.\n    lw t3, -4(t5)\n    lw t4, -8(t5)\n\n    # Compute and memoize the result.\n    add a0, t3, t4\n    sw a0, 0(t5)\n\n    addi t0, t0, 1\n    la t5, _fib_memo_internal_index\n    sw t0, (t5)\n\n    jr ra\n\n\n.data\n_fib_memo_internal_index:   .word 2\n_fib_memo_internal_storage: .word 0, 1\n                            .space 152\n\n.text\n################################################################################\n\n\n    .data\nfib_results:   .space 160           # space for first 40 terms of fib sequence\n```"
  }
]
