[
  {
    "id": "7_1",
    "title": "E7.1 Διάβασμα και εκτύπωση ενός αριθμού κινητής υποδιαστολής",
    "question": "Γράψτε ένα πρόγραμμα σε συμβολική γλώσσα RISC-V που θα διαβάζει από το παράθυρο της κονσόλας έναν αριθμό απλής ακρίβειας με τη χρήση της κλήσης συστήματος ReadFloat. Κατόπιν χρησιμοποιήσετε την κλήση PrintFloat για να τον εμφανίσετε στην οθόνη. Για περισσότερες πληροφορίες σχετικές με τις κλήσεις συστήματος μπορείτε να ανατρέξετε στο Παράρτημα Βʹ.\n\nαʹ. Πειραματιστείτε με αριθμούς που είναι δυνάμεις ή αθροίσματα δυνάμεων του 2, π.χ. −0.75, 1.0, 1.5, κ.α.\n\nβʹ. Πειραματιστείτε με τυχαίους αριθμούς. Τι παρατηρείτε;",
    "solution": "```\n# E7.1\n\n    .globl   start\n\n__start:\n    li a7, 6  # Syscall 6 : ReadFloat\n    ecall\n\n    li a7, 2  # Syscall 2 : PrintFloat\n    ecall\n\n    # when giving random numbers such as pi (some first digits,\n    # like 3.1415926535), the program rounds it to the 7th digit.\n\n    li  a7, 10\n    ecall\n\n    .data\n```"
  },
  {
    "id": "7_2",
    "title": "E7.2 Πράξεις με αριθμούς κινητής υποδιαστολής",
    "image": ["lab7_ex2"],
    "question": "Γράψτε ένα πρόγραμμα σε συμβολική γλώσσα RISC-V που να ορίζει με τη χρήση του τμήματος δεδομένων έξι σταθερές : 0.0, +∞, −∞, +NaN, και δύο αριθμούς κινητής υποδιαστολής, έναν θετικό x και έναν αρνητικό y. Ενδεχομένως να σας ενδιαφέρει η υποδομή αναπαράστασης 32-bit αριθμών κινητής υποδιαστολής με βάση το πρότυπο IEEE 754 που διαθέτει ο RARS (Tools → Floating Point Representation) και το Παράρτημα Αʹ.5.3.3. Το πρόγραμμα θα πρέπει να εκτελεί τις πράξεις που φαίνονται στον Πίνακα 6 και να εμφανίζει τα αποτελέσματά τους. Συμπληρώστε τον Πίνακα 6 σύμφωνα με τα αποτελέσματα που πήρατε.",
    "solution": "```\n# E7.2\n\n#---------------------- text segment ---------------------#\n    .text              # Program code goes in this section\n    .globl ___start    # Note: THREE underscores as specified\n\n___start:              # Execution starts here\n    # Load floating point values from memory\n    la a0, null\n    flw ft0, 0(a0)\n\n    la a0, pos_inf\n    flw ft1, 0(a0)\n\n    la a0, neg_inf\n    flw ft2, 0(a0)\n\n    la a0, not_a_number\n    flw ft3, 0(a0)\n\n    la a0, x\n    flw ft4, 0(a0)\n\n    la a0, y\n    flw ft5, 0(a0)\n\n    # Print headers for clarity\n    la a0, header\n    li a7, 4\n    ecall\n\n    # x - y\n    fsub.s fa0, ft4, ft5\n\n    la a0, msg1\n    li a7, 4\n    ecall\n\n    li a7, 2\n    ecall\n\n    la a0, newline\n    li a7, 4\n    ecall\n\n    # x * y\n    fmul.s fa0, ft4, ft5\n\n    la a0, msg2\n    li a7, 4\n    ecall\n\n    li a7, 2\n    ecall\n\n    la a0, newline\n    li a7, 4\n    ecall\n\n    # y / 0\n    fdiv.s fa0, ft5, ft0\n\n    la a0, msg3\n    li a7, 4\n    ecall\n\n    li a7, 2\n    ecall\n\n    la a0, newline\n    li a7, 4\n    ecall\n\n    # 0 / 0\n    fdiv.s fa0, ft0, ft0\n\n    la a0, msg4\n    li a7, 4\n    ecall\n\n    li a7, 2\n    ecall\n\n    la a0, newline\n    li a7, 4\n    ecall\n\n    # (+infinity) / (-infinity)\n    fdiv.s fa0, ft1, ft2\n\n    la a0, msg5\n    li a7, 4\n    ecall\n\n    li a7, 2\n    ecall\n\n    la a0, newline\n    li a7, 4\n    ecall\n\n    # (+infinity) + (-infinity)\n    fadd.s fa0, ft1, ft2\n\n    la a0, msg6\n    li a7,\n    ecall\n\n    li a7, 2\n    ecall\n\n    la a0, newline\n    li a7, 4\n    ecall\n\n    # x + (+NaN)\n    fadd.s fa0, ft4, ft3\n\n    la a0, msg7\n    li a7, 4\n    ecall\n\n    li a7, 2         # PrintFloat system call\n    ecall\n\n    la a0, newline\n    li a7, 4\n    ecall\n\n    li a7, 10         # Done, terminate program\n    ecall              # au revoir...\n\n    #########################################################\n    #         operation          |          output          #\n    #----------------------------|--------------------------#\n    #           x - y            |            12            #\n    #           x * y            |           -11            #\n    #           y / 0            |        -Infinity         #\n    #           0 / 0            |           NaN            #\n    # (+infinity) / (-infinity)  |           NaN            #\n    # (+infinity) + (-infinity)  |           NaN            #\n    #          x + (+NaN)        |           NaN            #\n    #########################################################\n\n#---------------------- data segment ---------------------#\n    .data              # Data declarations go in this section.\nnull:         .word 0x00000000\npos_inf:      .word 0x7F800000\nneg_inf:      .word 0xFF800000\nnot_a_number: .word 0x7FBFFFFF\nx:            .word 0x41300000   # 11\ny:            .word 0xBF800000   # -1\n\n# Messages for clarity\nheader:   .string \"Floating Point Operations Results:\\n\"\nmsg1:     .string \"x - y = \"\nmsg2:     .string \"x * y = \"\nmsg3:     .string \"y / 0 = \"\nmsg4:     .string \"0 / 0 = \"\nmsg5:     .string \"(+infinity) / (-infinity) = \"\nmsg6:     .string \"(+infinity) + (-infinity) = \"\nmsg7:     .string \"x + (+NaN) = \"\nnewline:  .string \"\\n\"\n#----------------------- End of File ---------------------#\n```"
  },
  {
    "id": "7_3",
    "title": "E7.3 Υπολογισμός του παραγοντικού",
    "question": "**αʹ.** Κατεβάστε από το eClass του μαθήματος το πρόγραμμα lab7_ex3.s και αποθηκεύστε το τοπικά στον υπολογιστή σας. Στη συνέχεια ανοίξτε το και μελετήστε το περιεχόμενό του. Περιλαμβάνει τον υπολογισμό του παραγοντικού με επαναληπτικό τρόπο. Φορτώστε το στον προσομοιωτή RARS και τρέξτε το. Τι παρατηρείτε; **βʹ.** Αλλάξτε το προηγούμενο πρόγραμμα έτσι ώστε ο υπολογισμός να γίνεται με αριθμητική κινητής υποδιαστολής απλής ακρίβειας. Τρέξτε το πρόγραμμα για n > 20 και παρατηρήστε τα αποτελέσματα.",
    "solution": "```\n# E7.3\n\n.text\n    .globl __start\n__start:\n\n    # As we can see, in the program given, the factorials calculated starting from \"13!\" and on are wrong\n    # (13! = 6227020800, not 1932053504). Also, there are some negative factorials\n    # calculated, such as 14!, which is shown to be equal to -288522240.\n    # Load n as integer first\n    la t0, n\n    lw t0, 0(t0)\n\n    # Initialize floating point registers\n    fcvt.s.w ft2, zero\n    li t1, 1\n    fcvt.s.w ft1, t1\n    fcvt.s.w ft3, t1\n\n    # Convert n to float for comparisons\n   fcvt.s.w ft0, t0\n\nloop:\n    # Calculate i! using floating point multiplication\n    fmul.s ft1, ft1, ft3\n\n    # Print i (convert float to int for printing)\n    fcvt.w.s a0, ft3\n    li a7, 1\n    ecall\n\n    # Display \"! is :\"\n    la a0, msg1\n    li a7, 4\n   ecall\n\n    # Print i! as float\n    fmv.s fa0, ft1\n    li a7, 2\n    ecall\n\n    # Print end of line\n    la a0, endl\n    li a7, 4\n   ecall\n\n    # Increment i by 1.0\n    li t1, 1\n    fcvt.s.w ft4, t1\n    fadd.s ft3, ft3, ft4\n\n    # Compare i <= n\n    fle.s t1, ft3, ft0\n    bnez t1, loop\n\n    li a7, 10               # exit\n    ecall\n\n.data\nn:      .word  25\nmsg1:   .asciz \"! is :\"\nendl:   .asciz \"\\n\"\n```"
  },
  {
    "id": "7_4",
    "title": "E7.4 Υλοποίηση εντολής κινητής υποδιαστολής",
    "question": "Η αρχιτεκτονική RISC-V διακρίνεται για τον αρθρωτό της σχεδιασμό (modular design), ο οποίος βασίζεται σε μια κύρια αρχιτεκτονική (base ISA), πάνω στην οποία μπορούν να προστεθούν διάφορες επεκτάσεις (ISA extensions).\n\nΟ ρόλος των επεκτάσεων είναι να μειώνουν τον αριθμό των εντολών που απαιτούνται για την εκτέλεση σύνθετων λειτουργιών, επιταχύνοντας έτσι την εκτέλεση των προγραμμάτων. Για παράδειγμα, η επέκταση κινητής υποδιαστολής απλής ακρίβειας RV32F της αρχιτεκτονικής RISC-V παρέχει εξειδικευμένες εντολές που μπορούν να αντικαταστήσουν πολλές ξεχωριστές εντολές σύγκρισης, διακλαδώσεων και αριθμητικών πράξεων. Όταν αυτές οι εντολές υλοποιούνται σε υλικό, μειώνεται τόσο ο χρόνος εκτέλεσης όσο και η κατανάλωση ενέργειας.\n\nΣε αυτή την άσκηση θα δούμε τον τόπο με τον οποίο μια εντολή της επέκτασης RV32F (ΚΥ απλής ακρίβειας του RISC-V) θα έπρεπε να υλοποιηθεί με συνδυασμό άλλων εντολών αν δεν υπήρχε ως μέρος της επέκτασης RV32F. Συγκεκριμένα, το ζητούμενο της άσκησης είναι να υλοποιήσετε ένα πρόγραμμα σε συμβολική γλώσσα RISC-V το οποίο θα εξομοιώνει τη λειτουργία της εντολής `flt.s` που ανήκει στην επέκταση RV32F.\n\nΚατεβάστε από το eClass του μαθήματος το πρόγραμμα **lab7_ex4.s**. Στη συνέχεια ανοίξτε το και μελετήστε το περιεχόμενό του. Αυτό το πρόγραμμα φορτώνει απλώς 2 αριθμούς σε αναπαράσταση ΙΕΕΕ 754 από τη μνήμη δεδομένων και εκτελεί την εντολή flt.s, η οποία συγκρίνει τους αριθμούς κινητής υποδιαστολής που βρίσκονται στους ft1 και ft2 και θέτει την τιμή 1 στον (ακέραιο) καταχωρητή t3 αν ισχύει `ft1` < `ft2`, αλλιώς θέτει την τιμή 0 στον `t3`.\n\nΤο πρόγραμμα που θα υλοποιήσετε θα πρέπει να εξομοιώνει αυτή τη λειτουργία αποκλειστικά με ακέραιες εντολές και καταχωρητές (εντολές δηλαδή που ανήκουν στην κύρια αρχιτεκτονική RV32I). Συγκεκριμένα, θέλουμε το πρόγραμμα να φορτώνει δύο αριθμούς σε αναπαράσταση ΙΕΕΕ 754 από τη μνήμη δεδομένων και να ελέγχει αν ο πρώτος αριθμός είναι μικρότερος από το δεύτερο. Αν ναι, τότε θα θέτει την τιμή 1 στον καταχωρητή `t4`, αλλιώς θα θέτει την τιμή 0 στον `t4`. Την υλοποίηση του προγράμματος μπορείτε να την κάνετε στο αρχείο που μόλις κατεβάσατε ώστε να επαληθεύσετε τη λειτουργία του συγκρίνοντας το αποτέλεσμα του `t4` (που προέκυψε από την εκτέλεση του δικού σας προγράμματος) με τον `t3` (που προέκυψε από την εκτέλεση της `flt.s`). Πόσες εντολές χρησιμοποιήσατε για να εξομοιώσετε τη λειτουργία της `flt.s`;",
    "solution": "```\n# E7.4\n    .text\n    .globl __start\n\n__start:\n    la t0, num1\n    lw t1, 0(t0)            # Load num1 into t1\n    lw t2, 4(t0)            # Load num2 into t2\n\n    #fmv.w.x ft1, t1         # Move IEEE 754 representation of num1 to ft1\n    #fmv.w.x ft2, t2         # Move IEEE 754 representation of num2 to ft2\n\n    #flt.s   t3, ft1, ft2    # if (ft1 < ft2) ? t3=1 : t3=0\n\n    srli t1, t0, 31 # logical shift right by 31 to extract the sign\n    andi t1, t1, 1 # mask to only keep the bit of the sign in t1 register\n\n    # repeat for the second number\n    srli t2, t0, 31\n    andi t2, t2, 1\n\n    beq t1, t2, equal_sign_check\n\n    beqz t1, first_greater\n    beqz t2, second_greater\n\n# equal sign case (checking sign)\nequal_sign_check:\n    beqz t1, equal_sign_positive\n    j equal_sign_negative\n\n# equal sign case (both positive)\nequal_sign_positive:\n    srli t1, t0, 1 # logical shift right to remove the sign\n    srli t1, t0, 24 # logical shift right by 31 to extract the exponent\n    srli t3, t3, 24 # shift to only keep the exponent bits in t3 register\n\n    # repeat for second number\n    srli t2, t0, 1\n    srli t2, t0, 24\n    srli t4, t4, 24 # keeping the exponent bits for the second number in t4 registern\n\n    bgt t3, t4, first_greater\n    bgt t3, t4, second_greater\n\n# equal sign case (both negative)\nequal_sign_negative:\n    srli t1, t0, 1 # logical shift right to remove the sign\n    srli t1, t0, 24 # logical shift right by 31 to extract the exponent\n    srli t3, t3, 24 # shift to only keep the exponent bits in t3 register\n\n    # repeat for second number\n    srli t2, t0, 1\n    srli t2, t0, 24\n    srli t4, t4, 24 # keeping the exponent bits for the second number in t4 register\n\n    # reverse order from the case when they're both positive\n    bgt t3, t4, second_greater\n    bgt t3, t4, first_greater\n\n# in this case the first number is greater, so we load the value 1 to t3 register\nfirst_greater:\n    li t3, 0\n    j end\n\n# in this case the second number is greater, so we load the value 0 to t3 register\nsecond_greater:\n    li t3, 1\n    j end\n\nend:\n    li a7, 10\n    ecall\n\n    .data\nnum1:   .word 0x6f800000\nnum2:   .word 0x4f800200\n```"
  }
]
