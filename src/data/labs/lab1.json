[
  {
    "id": "1_3",
    "title": "E1.3 Διαδικασία αποσφαλμάτωσης στον RARS",
    "question": "Υπάρχουν δύο είδη σφαλμάτων, τα συντακτικά και τα λογικά λάθη. Τα συντακτικά λάθη εντοπίζονται κατά τη συμβολομετάφραση και πρέπει να επιλυθούν προκειμένου να εκτελεστεί ο κώδικας.\n\nΔυσκολότερα αντιμετωπίζονται τα λογικά λάθη που προκύπτουν από τη λανθασμένη υλοποίηση του αλγορίθμου στον κώδικα και έχουν ως απόρροια μη αναμενόμενα αποτελέσματα κατά την εκτέλεση.\n\nΓενικά, για την διόρθωση λογικών λαθών χρησιμοποιούμε:\n\n- Βηματική εκτέλεση του προγράμματος παρατηρώντας τις τιμές τόσο των καταχωρητών όσο και της μνήμης (Εικόνα 6) και συγκρίνοντας τες με τις αναμενόμενες.\n\n- Σημεία διακοπής. Ένα σημείο διακοπής (breakpoint) είναι μια θέση στο πρόγραμμα, όπου η εκτέλεση θα διακοπεί πριν εκτελεστεί η εντολή που βρίσκεται στη θέση αυτή. Όταν το πρόγραμμα σταματήσει στο σημείο αυτό, η κατάσταση του προγράμματος μπορεί να ελεγχθεί με την προβολή των περιεχομένων των καταχωρητών και της μνήμης.\n\nΚατεβάστε το αρχείο **lab1_errors.s** από το eClass του μαθήματος, φορτώστε το στον προσομοιωτή RARS και δοκιμάστε να το συμβολομεταφράσετε. Το αποτέλεσμα που θα πάρετε θα είναι παρόμοιο με αυτό της Εικόνας 7. Παρατηρείστε ότι αν πατήσετε πάνω σε κάποιο σφάλμα, θα χρωματιστεί και η αντίστοιχη γραμμή που το περιέχει.\n\nΤα πρώτα δύο σφάλματα είναι ίδια και αναφέρονται στη αναγνώριση λανθασμένου τελεστέος (`t7`). Κοιτώντας τους καταχωρητές θα διαπιστώσετε ότι δεν υπάρχει τέτοιος καταχωρητής αφού οι προσωρινοί καταχωρητές είναι από `t0`-`t6`. Αλλάξτε το πρόγραμμα έτσι ώστε να μην χρησιμοποιείται ο `t7` αλλά ο `t1`.\n\nΤο επόμενο σφάλμα αναφέρεται πάλι σε λανθασμένο τελεστέο. Αυτή τη φορά, υπάρχει πρόβλημα σχετικά με την σταθερά 1 δεδομένου ότι χρησιμοποιείται η εντολή `add`, η οποία απαιτεί τρεις καταχωρητές για τελεστέους. Αλλάξτε την εντολή add σε addi και επαναλάβετε την μετάφραση.\n\nΤρέξτε το πρόγραμμα χωρίς διακοπή. Τι παρατηρείτε;\n\nΔοκιμάστε να βάλετε σημείο διακοπής (breakpoint) στην εντολή με διεύθυνση `0x00400020` (`auipc x10`, `0x0000fc10`) επιλέγοντας το τετράγωνο δίπλα από τη διεύθυνση (Εικόνα 8)\n\nΤρέξτε το πρόγραμμα εξ ολοκλήρου και επιβεβαιώστε ότι η εκτέλεση θα σταματήσει στο σημείο που επιλέξατε. Στο συγκεκριμένο σημείο εκτέλεσης ο καταχωρητής `t1` θα πρέπει να περιέχει την τιμή 11. Τι παρατηρείτε; Τρέξτε βηματικά το υπόλοιπο πρόγραμμα παρατηρώντας τις αλλαγές στις τιμές των καταχωρητών και προσπαθήστε να το διορθώσετε.",
    "solution": "```\n# E1.3\n    .text\n    .globl __start\n__start:\n    la t2, str          # t2 points to the string\n    li t3, 0            # t3 holds the count (replace t7, which doesn't exist, with t3) \nnextCh: \n    lb t0, 0(t2)        # get a byte from string\n    beqz t0, strEnd     # zero means end of string\n    addi t3, t3, 1      # increment count\n    addi t2, t2, 1      # move pointer one character (change the command from `add`\n                        #  to `addi` so the counter can be increased\n                        #  by an immediate value)\n    j nextCh            # go round the loop again\nstrEnd:\n    la a0, ans          # system call to print out\n    li a7, 4            # a message\n    ecall\n    mv a0, t3           # system call to print out (change this\n            # from t2 to t3, since t2 contains the string\n            # pointer, while t3 counts the amount of characters in the string)\n    li a7, 1            # the length\n    ecall\n    la a0, endl         # system call to print out\n    li a7, 4            # end of line\n    ecall\n    li a7, 10           # au revoir ...\n    ecall\n\n\n    .data\nstr:    .asciz \"hello world\"\nans:    .asciz \"Length is \"\nendl:   .asciz \"\\n\"\n```"
  }
]
