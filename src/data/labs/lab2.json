[
  {
    "id": "2_1",
    "title": "E2.1 Φόρτωση και αποθήκευση αριθμών",
    "question": "Κατεβάστε από το eClass του μαθήματος το πρότυπο προγραμμάτων συμβολικής γλώσσας RISC-V (template.s). Μετονομάστε το αρχείο σε lab2_ex1.s και ανοίξτε το για να ξεκινήσετε τη συγγραφή του κώδικά σας για αυτή την άσκηση.\n\nΘεωρήστε το τμήμα δεδομένων που παρουσιάζεται στον Κώδικα 1. Όπως βλέπετε, έχουν δηλωθεί δύο αριθμοί A και B.\n\n**αʹ.** Να αντιγράψετε τον Κώδικα 1 στο τμήμα δεδομένων του προγράμματός σας.\n\n**βʹ.** Στη συνέχεια, στο κυρίως πρόγραμμα (στο τμήμα κώδικα – κάτω από την ετικέτα `__start`:) χρησιμοποιήστε το ζευγάρι εντολών που αποτελείται από την ψευδοεντολή `la` (load address) και την πραγματική εντολή `lw` (load word) για να φορτώσετε στους καταχωρητές s0, s1 τους αριθμούς A και B από τη μνήμη δεδομένων.\n\n**γʹ.** Υπολογίστε το άθροισμα των δύο αριθμών και αποθηκεύστε το αποτέλεσμα στον καταχωρητή `s2`.\n\n**δʹ.** Αποθηκεύστε το αποτέλεσμα στη θέση μνήμης που δηλώνει η ετικέτα `sum` χρησιμοποιώντας το ζευγάρι εντολών που αποτελείται από την ψευδοεντολή `la` (load address) και την πραγματική εντολή αποθήκευσης στη μνήμη δεδομένων `sw` (store word).\n\n**εʹ.** Φορτώστε και εκτελέστε βηματικά το πρόγραμμά σας στον RARS. Παρατηρήστε τις αλλαγές στα περιεχόμενα των καταχωρητών που χρησιμοποιήσατε όπως φαίνονται στο υπο-παράθυρο καταχωρητών του RARS καθώς εκτελούνται (βηματικά) οι εντολές, όπως και τη μνήμη δεδομένων στην οποία φαίνεται το άθροισμα των αριθμών A και B.\n\nΚώδικας 1:\n\n```\n    .data\nA:      .word 2\nB:      .word 3\nsum:      .word 0\n\n```",
    "solution": "```\n# E2.1\n\n#---------------------- text segment ---------------------#\n\n    .text              # Program code goes in this section\n    .globl __start\n\n__start:               # Execution starts here\n\n### subexercise B ###\n\n# load the addresses of A and B to t0 and t1 respectively\n    la t0, A\n    la t1, B\n\n# load the words to s0 and s1 with offset 0 from registers t0 and t1\n    lw s0, 0(t0)\n    lw s1, 0(t1)\n\n### subexercise C ###\n\n# add the two numbers and save the sum to register s2\n    add s2, s0, s1\n\n### subexercise D ###\n\n# load the address of sum to t2\n    la t2, sum\n\n# and store the word to t2 with offset 0\n    sw s2, 0(t2)\n\n    li  a7, 10         # Done, terminate program\n    ecall              # au revoir...\n\n\n### subexercise E ###\n\n# when running the program you can observe that at the start, numbers 2 and 3\n# are seen in the data segment. during execution, the addresses containing `A` and `B`\n# are loaded to register t0 and t1, while 2 and 3 are loaded in registers\n# s0 and s1, as seen in the registers window to the right.\n# the sum of 2 and 3 is saved to register s2 and after loading the address of\n# word `sum` to t2, the contents of s2 are stored to t2 with offset 0.\n# after storing the sum, number 5 can be seen in the data segment.\n\n\n  #---------------------- data segment ---------------------#\n\n    .data   # Data declarations go in this section.\n### subexercise A ###\nA:      .word 2\nB:      .word 3\nsum:   .word 0\n#----------------------- End of File ---------------------#\n\n\nΆλλη λύση:\n\n# E2.1 with only one `la` command\n\n#---------------------- text segment ---------------------#\n\n    .text              # Program code goes in this section\n    .globl __start\n\n__start:               # Execution starts here\n\n### subexercise B ###\n\n# load only the addresses of A to t0\n    la t0, A\n\n# load the words from t0 with offset 0 to s0 and with offset 4 to s1\n    lw s0, 0(t0)\n    lw s1, 4(t0)\n\n### subexercise C ###\n\n# add the two numbers and save the sum to register s2\n    add s2, s0, s1\n\n### subexercise D ###\n\n# and store the word to t0 with offset 8, so it is saved to the address of `sum`\n    sw s2, 8(t0)\n\n    li  a7, 10         # Done, terminate program\n    ecall              # au revoir...\n\n\n### subexercise E ###\n\n# when running the program you can observe that at the start, numbers 2 and 3\n# are seen in the data segment. during execution, only the addresses containing `A`\n# is loaded to register t0, while 2 and 3 are loaded in registers\n# s0 and s1, as seen in the registers window to the right.\n# since the address are in order, there is no need to load more than one address\n# and it can be manipulated corectly using offsets.\n# the sum of 2 and 3 is saved to register s2 and it is stored to t0 with offset 8.\n# after storing the sum, number 5 can be seen in the data segment.\n\n\n #---------------------- data segment ---------------------#\n\n    .data   # Data declarations go in this section.\n### subexercise A ###\nA:      .word 2\nB:      .word 3\nsum:    .word 0\n#----------------------- End of File ---------------------#```"
  },
  {
    "id": "2_2",
    "image": ["lab2_ex2"],
    "title": "E2.2 Διευθύνσεις μνήμης και δεδομένα",
    "question": "Κατεβάστε από το eClass του μαθήματος το πρότυπο προγραμμάτων συμβολικής γλώσσας RISC-V (template.s). Μετονομάστε το αρχείο τοπικά στον υπολογιστή σας σε lab2_ex2.s και ανοίξτε το για να ξεκινήσετε τη συγγραφή του κώδικά σας για αυτή την άσκηση.\n\nΘεωρήστε το τμήμα δεδομένων που παρουσιάζεται στον Κώδικα 2. Όπως βλέπετε, έχουν δηλωθεί 4 διαδοχικά bytes και μια λέξη (word) εκφρασμένη σε δεκαεξαδικό σύστημα. Επομένως, έχουμε συνολικά 4 + 4 = 8 bytes στη μνήμη δεδομένων.\n\n*αʹ.* Να αντιγράψετε τον Κώδικα 2 στο τμήμα δεδομένων του προγράμματός σας.\n\n*βʹ.* Φορτώστε και συμβολομεταφράστε το πρόγραμμά σας στον RARS. Παρατηρήστε τη μνήμη δεδομένων στον RARS και συμπληρώστε τον Πίνακα 1αʹ.\n\n*γʹ.* Φορτώστε τη λέξη που ξεκινά από τη διεύθυνση 0x10010000 στον καταχωρητή s0 και συμπληρώστε τον Πίνακα 1βʹ.\n\n*δʹ.* Τι σχέση έχει το περιεχόμενο της θέσης μνήμης 0x10010000 με το Byte 0 του καταχωρητή s0;\n\nΟ RISC-V χρησιμοποιεί την οργάνωση «μικρού άκρου» (little-endian) με αποτέλεσμα το λιγότερο σημαντικό byte (Byte 0) να βρίσκεται στη μικρότερη διεύθυνση μνήμης. Για παραπάνω λεπτομέρειες μπορείτε να ανατρέξετε στο Παράρτημα Αʹ.2.\n\n*εʹ.* Εντοπίστε τα περιεχόμενα των διευθύνσεων 0x10010003 και 0x10010007. Συγκρίνετε τα bytes θεωρώντας ότι αναπαριστούν προσημασμένους χαρακτήρες (signed char). Αλλάζει το αποτέλεσμα εάν τα συγκρίνουμε ως απροσήμαστους χαρακτήρες (unsigned char); Αιτιολογείστε την απάντησή σας.\n\n```\n    .data\nBytes:      .byte 0x11, 0x22, 0x33, 0x44\nWord:       .word 0x88776655\n```",
    "solution": "```\n# E2.2\n\n#---------------------- text segment ---------------------\n\n    .text              # Program code goes in this section\n    .globl __start\n\n__start:               # Execution starts here\n\n### subexercise B ###\n\n################################\n#  Byte Address  |    Data     #\n#   0x10010000   |    0x11     #\n#   0x10010001   |    0x22     #\n#   0x10010002   |    0x33     #\n#   0x10010003   |    0x44     #\n#   0x10010004   |    0x55     #\n#   0x10010005   |    0x66     #\n#   0x10010006   |    0x77     #\n#   0x10010007   |    0x88     #\n################################\n\n### subexercise C ###\n\n# load the word that start at address 0x10010000\n    lw s0, 0x10010000\n\n####################################\n#  Byte 3  Byte 2  Byte 1  Byte 0  #\n#    44      33      22      11    #\n####################################\n\n### subexercise D ###\n\n# at address 0x10010000 are stored both the start of the first word and\n# the first byte (Byte 0)\n\n### subexercise E ###\n\n# the contains of addresses 0x10010003 and 0x10010007 can't be directly\n# compared, since they are not inline for either halfword or word access\n\n\n    li  a7, 10         # Done, terminate program\n    ecall              # au revoir...\n\n\n#---------------------- data segment ---------------------#\n\n    .data   # Data declarations go in this section.\n### subexercise A ###\nBytes:    .byte 0x11, 0x22, 0x33, 0x44\nWord:     .word 0x88776655\n\n#----------------------- End of File ---------------------#\n```"
  },
  {
    "id": "2_3",
    "title": "E2.3 Ακολουθία αριθμών στη μνήμη",
    "question": "Θεωρείστε τον Κώδικα 3. Η εντολή `lw t0, 4(t0)` υπάρχει *k* φορές.\n\n*αʹ.* Τρέξτε τον Κώδικα 3 με k εντολές `lw t0, 4(t0)` κάθε φορά, *0 ≤ k ≤ 4*, και καταγράψτε το *k*-στό περιεχόμενο του `s0` μετά το πέρας κάθε εκτέλεσης.\n\n*βʹ.* Τρέξτε βηματικά την καθεμιά από τις *k + 1* προσομοιώσεις και παρατηρήστε τις αλλαγές στα περιεχόμενα των καταχωρητών που σας ενδιαφέρουν. Σας θυμίζει κάτι αυτή η συμπεριφορά;\n\n*γʹ.* Επεκτείνετε τον Κώδικα 3 προσθέτοντας μόνο εντολές `sw` και `addi`, έτσι ώστε η ακολουθία a_k που αποτυπώνει το k-στό περιεχόμενο του καταχωρητή `s0` μετά το πέρας της κάθε εκτέλεσης να ισούται με a_k = {1, 3, 5, 12, 7, 9}.\n\nΚώδικας 3:\n\n```\n    .text\n   .globl __start\n\n__start:\n    la t0, Elements\n\n    lw to, 4(t0)\n    lw t0, 4(t0)\n    .\n    .\n    .\n    lw t0, 4(t0)\n\n    lw s0, 0(t0)\n    li a7, 10\n    ecall\n\n    .data\nElements:     .word 1, 0x10010020, 9, 0\n              .word 5, 0x10010018, 7, 0x10010008\n              .word 3, 0x10010010, 0, 0\n```",
    "solution": "```\n# E2.3\n\n#---------------------- text segment ---------------------#\n\n    .text              # Program code goes in this section\n    .globl __start\n\n__start:               # Execution starts here\n\n    la t0, Elements\n\n    # add to a register the number 12\n    addi t1, zero, 12\n\n    # store it in a location that has room\n    sw t1, 40(t0)\n\n    # add to a register the address 0x10010000 (t0) + x18 (hex representaion of 24)\n    addi t1, t0, 0x18\n\n    # store the address of the next number in the sequence (7)\n    sw t1, 44(t0)\n\n    # now change the order to go from 5 to 12\n    addi t1, t0, 40\n    sw t1, 20(t0)\n\n\n    lw t0, 4(t0)\n    lw t0, 4(t0)\n    lw t0, 4(t0)\n    lw t0, 4(t0)\n    lw t0, 4(t0)    #add one more of this commands for the new number in the set\n\n    lw s0, 0(t0)\n\n    li  a7, 10         # Done, terminate program\n    ecall              # au revoir...\n\n### subexercise A ###\n\n# reps of `lw t0, 4(t0)` |      0      |      1      |      2      |      3      |      4      |\n#           s0           |  0x00000001 |  0x00000003 |  0x00000005 |  0x00000007 |  0x00000009 |\n### subexercise B ###\n\n# this program simulates a linked-list data structure, where a node contains a value\n# and the address of the next node\n\n#---------------------- data segment ---------------------#\n\n    .data   # Data declarations go in this section.\nElements:  .word 1, 0x10010020, 9, 0\n       .word 5, 0x10010018, 7, 0x10010008\n         .word 3, 0x10010010, 0, 0\n\n#----------------------- End of File ---------------------#\n```"
  },
  {
    "id": "2_4",
    "title": "E2.4 Διάβασμα και εκτύπωση ενός ακέραιου αριθμού",
    "question": "Η κονσόλα αποτελεί τη διεπαφή αλληλεπίδρασης του χρήστη με το πρόγραμμα. Να γράψετε πρόγραμμα σε συμβoλική γλώσσα RISC-V χρησιμοποιώντας το πρότυπο προγραμμάτων (template.s), στο οποίο θα διαβάζετε έναν ακέραιο αριθμό από την κονσόλα (καρτέλα Run I/O του RARS) και θα τον εκτυπώνετε. Μπορείτε να συμβουλευτείτε το Παράρτημα Βʹ για πληροφορίες σχετικά με τις κλήσεις συστήματος και το πως αυτές χειρίζονται στον προσομοιωτή RARS.",
    "solution": "```\n# E2.4\n\n#---------------------- text segment ---------------------#\n\n    .text              # Program code goes in this section\n    .globl __start\n\n__start:               # Execution starts here\n\n# read integer from inpu. the input will be saved in register a0\n    li a7, 5\n    ecall\n\n# since the integer is already in register a0, there is no need to \n# move it anywhere. so the printing process can be called.\n    li a7, 1\n    ecall\n\n    li  a7, 10         # Done, terminate program\n    ecall              # au revoir...\n\n\n#---------------------- data segment ---------------------#\n\n    .data   # Data declarations go in this section.\n\n\n\n#----------------------- End of File ---------------------#\n```"
  }
]
