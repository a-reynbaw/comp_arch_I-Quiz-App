[
  {
    "number": "7",
    "question": "(Στο κουίζ 7 το πρόβλημα είναι το ίδιο με το κουίζ 6 αλλά ο στόχος διαφορετικός.)\n\n Οι μεταβλητές a, b, c, d ενός προγράμματος που θα εκτελεστεί σε επεξεργαστή RISC-V μεταφέρονται αρχικά στους καταχωρητές x6, x7, x8, x9 (δηλαδή πρέπει να εκτελεστούν οι εντολές la και lw που φέρνουν τις τιμές τους από τη μνήμη στους καταχωρητές). Οι αριθμοί είναι απρόσημοι.\nΝα γράψετε το υπόλοιπο του προγράμματος που υπολογίζει την τιμή της παράστασης \\( \\text{a} \\times \\text{b} + \\text{c} \\times \\text{d} \\) χωρίς να χρησιμοποιήσετε εντολές πολλαπλασιασμού ή διαίρεσης (μπορείτε να υποθέσετε ότι δεν υπάρχει ενδεχόμενο υπερχείλισης οπότε δεν χρειάζεται να κάνετε κανέναν σχετικό έλεγχο). Μπορείτε να χρησιμοποιήσετε όλες τις υπόλοιπες εντολές που μάθαμε ως τώρα και όποιους άλλους καταχωρητές θέλετε. Η τελική τιμή της παράστασης να αποθηκεύεται στον καταχωρητή x10.\n**Το πρόγραμμά σας να εκτελεί αυτή τη φορά τις λιγότερες δυνατές δυναμικές εντολές.** Στο πλήθος εντολών που εκτελούνται να υπολογίζονται όλες οι εντολές του προγράμματός σας. Για να δείτε πόσες εντολές εκτελεί το πρόγραμμά σας χρησιμοποιήστε τα εργαλεία Instruction Statistics ή Instruction Counter του RARS.\n**Ποιος είναι ο αριθμός των εντολών που εκτελεί το πρόγραμμά σαςόταν οι τιμές των αριθμών είναι a=25, b=12, c=41, d=17;**",
    "solution": "Παρουσιάζεται ο τρόπος μέτρησης των δυναμικών εντολών (δηλαδή των εντολών που εκτελούνται) για τις δύο λύσεις του προηγούμενου Κουίζ 6.\nΟ πρώτος κώδικας:\n\n```\n    .text\n    .globl __start\n__start:\n    la x3, a\n    lw x6, 0(x3)\n    la x3, b\n    lw, x7, 0(x3)\n    la x3, c\n    w x8, 0(x3)\n    la x3, d\n    lw x9, 0(x3)\n    add x11, x0, x0    # clear the product\naxb: add x11, x11, x6  # add multiplicant to product\n    addi x7, x7, -1    # minus 1 the multiplier\n    bgt x7, x0, axb    # continue if > zero\n    add x12, x0, x0    # clear the product\ncxd: add x12, x12, x8  # add multiplicant to product\n    addi x9, x9, -1    # minus 1 the multiplier\n    bgt x9, x0, cxd    # continue if > zero\n    add x10, x11, x12\n    li a7, 10          # Done, terminate program\n    ecall              # au revoir...\n```\nO δεύτερος κώδικας\n```\n    .text\n    .globl __start\n__start:\n    la x3, a\n    lw x6, 0(x3)\n    la x3, b\n    lw, x7, 0(x3)\n    la x3, c\n    lw x8, 0(x3)\n    la x3, d\n    lw x9, 0(x3)\n    add x10, x0, x0    # clear the product\naxb: add x10, x10, x6  # add multiplicant to product\n    addi x7, x7, -1    # minus 1 the multiplier\n    bgt x7, x0, axb    # continue if > zero\ncxd: add x10, x10, x8  # add multiplicant to product\n    addi x9, x9, -1    # minus 1 the multiplier\n    bgt x9, x0, cxd    # continue if > zero\n    li a7, 10          # Done, terminate program\n    ecall              # au revoir...\n```\nΠριν εκτελέσουμε το πρόγραμμα μέχρι τέλους, ανοίγουμε το Tool που ονομάζεται Instruction Statistics (ή το Instruction Counter) και κάνουμε Connect to Program.\nΚατόπιν εκτελούμε το πρόγραμμα μέχρι τέλους.\nΤο αποτέλεσμα για τα δύο προγράμματα είναι:\n\n- Πρόγραμμα 9 εντολών -> εκτελεί 62\n- Πρόγραμμα 7 εντολών -> εκτελεί 102",
    "answers": [
      {
        "text": "Δες ενδεικτική λύση",
        "correct": true
      }
    ]
  }
]
